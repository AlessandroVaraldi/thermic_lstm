// engine.h
#pragma once
#include <stdint.h>
#include <stddef.h>
#include "model_int8.h"  // shapes, FC_M_Q15/FC_RSHIFT, MP flags, etc.
#include "weights.h" 

// Fixed-point types
typedef int8_t  q7_t;   // Q1.7
typedef int16_t q15_t;  // generic fixed
typedef int32_t q31_t;  // accum

// Saturation helpers
static inline int8_t  sat8 (int32_t x){ if(x>127) return 127; if(x<-128) return -128; return (int8_t)x; }
static inline int16_t sat16(int32_t x){ if(x>32767) return 32767; if(x<-32768) return -32768; return (int16_t)x; }

// Gate requant params (per gate, per layer, per row)
typedef struct {
  const int16_t *m_ih_q15;  // H elems
  const int16_t *m_hh_q15;  // H elems
  const uint8_t *rshift;    // H elems (common after alignment)
  const int32_t *bias_q;    // H elems (already combined at export)
} gate_rq_t;

// Per-layer package
typedef struct {
  // W: row-major, dims: (4H x IN) and (4H x H)
  const int8_t *Wih;        // (4H*IN)
  const int8_t *Whh;        // (4H*H)
  // Gate requants
  gate_rq_t rq_i, rq_f, rq_g, rq_o;
  // Activations LUT (size 256)
  const uint8_t *lut_sigma_i; // UQ8
  const uint8_t *lut_sigma_f; // UQ8
  const uint8_t *lut_sigma_o; // UQ8
  const int8_t  *lut_tanh_g;  // SQ8
  // Row ranges for gates in stacked [4H,*] (inclusive start, exclusive end)
  uint16_t row_i0, row_i1;
  uint16_t row_f0, row_f1;
  uint16_t row_g0, row_g1;
  uint16_t row_o0, row_o1;
  // Input size to this layer (IN for L0, H otherwise)
  uint16_t in_dim;
} layer_t;

// FC head
typedef struct {
  const int8_t  *W;     // (1 x 2H)
  const int32_t *b;     // (1)
  int16_t  m_q15;       // requant
  uint8_t  rshift;      // requant
} fc_t;

// Whole model descriptors (pointers into arrays generated by exporter)
typedef struct {
  uint16_t L, H, D, Wseq;
  const layer_t *layers;      // array length L
  const fc_t    *fc;          // single head
  const int8_t  *lut_tanh_c;  // 65536 entries (int8 Q1.7), index = (c_q12 + 32768)
  uint8_t  c_frac_bits;       // typically 12 (Q3.12)
  // MP-time
  uint8_t  mp_enabled;        // 0/1
  uint16_t mp_tau_thr_q12;    // threshold on |Î”x_norm| in Q4.12
} lstm_model_t;

// API
void lstm_reset_states(q15_t *c, q7_t *h, uint16_t H, uint16_t L);
void lstm_forward_window( // x_s8 are normalized INT8 inputs
  const lstm_model_t *M,
  const q7_t *x_s8,       // [Wseq*D]
  q7_t *y_s8              // (1) normalized output in Q1.7
);
